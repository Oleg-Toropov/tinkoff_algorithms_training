package Tinkoff_7;

/*
Этот код решает задачу о Тайном Санте, где необходимо сделать так, чтобы каждый ученик дарил подарок ровно одному
другому ученику, образуя замкнутую цепочку.
Сначала мы находим ученика, которому необходимо изменить свой выбор, и ученика, который не получил подарка.
Затем мы проверяем, можно ли после такого изменения образовать цепочку подарков, которая начинается и заканчивается
на одном и том же ученике, проходя через всех учеников по одному разу.
 */

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        // Создаем массив для хранения информации о том, кто кому дарит подарок. Размер массива на 1 больше, чтобы индексы совпадали с номерами школьников.
        int[] a = new int[n + 1];
        // Создаем массив для подсчета количества подарков, полученных каждым школьником.
        int[] inDegree = new int[n + 1];

        // Заполняем массивы a и inDegree, считывая входные данные и увеличивая счетчики подарков.
        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextInt();
            inDegree[a[i]]++;
        }

        // Переменные для хранения номера ученика, которому подарили два подарка, и ученика, которому не подарили ни одного.
        int twice = -1; // Ученик с двумя подарками
        int none = -1; // Ученик без подарков

        // Перебираем всех учеников, чтобы найти ученика с двумя подарками и без подарков.
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == 2) twice = i;
            if (inDegree[i] == 0) none = i;
        }

        // Проверяем, найдены ли ученик с двумя подарками и ученик без подарков.
        if (twice == -1 || none == -1) {
            // Если нет, то задача не имеет решения.
            System.out.println("-1 -1");
        } else {
            // Если да, то ищем, кто подарил twice, чтобы изменить на none.
            for (int i = 1; i <= n; i++) {
                if (a[i] == twice) {
                    a[i] = none;
                    // Проверяем, образует ли новая конфигурация цикл.
                    if (checkCycle(a, i)) {
                        // Если да, выводим ответ и завершаем программу.
                        System.out.println(i + " " + none);
                        return;
                    }
                    // Если не получается сделать цикл, восстанавливаем первоначальное значение.
                    a[i] = twice;
                }
            }
            // Если не удалось найти подходящее изменение, выводим -1 -1.
            System.out.println("-1 -1");
        }
    }

    // Метод для проверки, образует ли граф цикл после предполагаемой замены.
    private static boolean checkCycle(int[] a, int start) {
        // Массив для отметки посещенных учеников.
        boolean[] visited = new boolean[a.length];
        // Начинаем проверку с измененного ученика.
        int current = start;
        // Счетчик для подсчета количества учеников в потенциальном цикле.
        int count = 0;

        // Перебираем учеников, следуя цепочке подарков, пока не вернемся к началу или не встретим посещенного ученика.
        while (!visited[current]) {
            visited[current] = true;
            current = a[current];
            count++;
            // Если цикл слишком длинный, значит, мы зациклились и должны остановиться.
            if (count > a.length - 1) {
                return false;
            }
        }

        // Проверяем, что количество учеников в цикле равно общему количеству и что мы вернулись в начало.
        return count == a.length - 1 && current == start;
    }
}
